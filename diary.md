# AHC014

## 2022-09-17

第一印象としては、2週間に足る深い問題なのかよくわからない、そうに違いないはずだとは思うが…。

スコアの正規化も、ケース間でこれで平等な感じなのかよくわからない。

とりあえずわかるのはこのくらい

* スコア計算的には一番外まで埋めていかないとどうしようもない。重みが距離の二乗で、かつ遠い方が点の数が多い（一番遠い角の所は別だけど）
* 斜めの四角を使わないと外側へは出て行けない
* 逆に、辺平行な四角を使わないと45度斜めのバウンディングボックスの外側へは出て行けない
* 他のを置くときの邪魔にならないようにできるだけ小さい四角形を使ったほうが良さそう？

ランダムに置いていくのを書いてみて、どんな風に行き詰まっちゃうのかを見てみよう。

Nが最大61なの、64bit整数で管理できてやさしい

正方形と思い込んで考えちゃってたけど長方形だった。細長いのを使うべきか使わないべきか、という観点はありそう

適当に置いていくのをやってみた。やっぱりちゃんと考えてやらないと外側になかなか進出できない。なるほどなあ

点の依存関係はDAGになって、既存の点によって邪魔されるときはそれを取り除きながら四角形を作るということもできそうではある。
有効かどうかはよくわからない

初期状態の中心1/4の範囲から出て行くには斜めの四角を使わないといけなくて、そのためには内部で斜めを使っていると邪魔になるので、
内部では斜めの四角はできるだけ使わないようにしてみた
=> 2%くらいは良くなったけど今の時点ではあまり意味が無い差でしかないなあ、スコアあと数倍にはしないといけないだろうし

無思考でビームサーチにはできるけどむやみにやっても大した成果にはならなそうな気はする。

とりあえず、一度始点として探索して見つからなかった点はその後もう調べなくて良い（追加した点からの探索でカバーされる）のでそれを削減して高速化できる

点があるかの情報を64bitじゃなく32bitで持っててNが大きいときにバグり散らかしてた… 直したらだいぶ上がって現順位表の1桁くらいにはなった

見る点の順序の入れ替えで山登りするのはすぐ出来るのでやってみた。一応上がることは上がるが2%とかなのでこんなことしててもナアという感じ。

現状
```
seed:0000 517052
seed:0001 699365
seed:0002 650085
seed:0003 722892
seed:0004 792839
seed:0005 704888
seed:0006 726640
seed:0007 908438
seed:0008 804148
seed:0009 870910
```

こんなふうな遷移で焼くことはできる。

* ある点と、それに依存している点をすべて取り除く
* それによって置けるようになる四角を置く
* 置かれた点を使う四角を置く
* さらに新たに置かれた点を使う四角を置く、を置けなくなるまで繰り返し

依存している点を除くところでめちゃくちゃ除かれて下がってばっかりになりそうな気もするが


## 2022-09-18

既存の辺上に点を置けて逆はできないことを考えると、最初の方は大きな四角を優先して作って小さい四角は後から置いた方がよさそう？

各点について各方向で最短の別の点までの距離を保持して毎回計算しないようにしてみたけど別に速くならなかった

外側に進出できた点が依存している点以外を取り除いて再度置いていく、をやってみる
=> 5%くらいよくなった。特にNが小さいケースでの伸び幅が大きい

100万点超えケースのビジュアライズを見てみたけど、外側にどんどん進出してるのではなく、初期四角の角のほうをびっしり埋めることができてる系だった。
ということは、外側に出て行けるような構築的な方法を探るのではなく、単純に探索頑張る方針でいけそうなのか。

置ける四角を探索するとき、既に置かれてる点を通過して線を引いて、今探索してる四角を先に置いたことにする、という順序関係の逆転が可能。
めっちゃ探索遅くなりそうではあるが

多めに多スタートするとだいぶ良くなっていそう。
まあ多スタートで良くなるということは探索の筋がそんなに良くないということを示していそうだが…

現状（実行1秒）
```
seed:0000 645653
seed:0001 922018
seed:0002 736755
seed:0003 782192
seed:0004 846125
seed:0005 721828
seed:0006 805711
seed:0007 1041660
seed:0008 924891
seed:0009 980071
```

> 外側に出て行けるような構築的な方法を探るのではなく、単純に探索頑張る方針でいけそうなのか。

と思ったけど1位のスコア見てみるとわからんな…

> 置ける四角を探索するとき、既に置かれてる点を通過して線を引いて、今探索してる四角を先に置いたことにする、という順序関係の逆転が可能。

これをやってみた（少々バグ残ってる）が全然良くならない
=> バグ直したけどやっぱりよくはなさそう…？


焼きなましにして多スタートやめてみたら割と上がった。意外。

```
seed:0000 675061
seed:0001 997528
seed:0002 781074
seed:0003 967785
seed:0004 823939
seed:0005 729884
seed:0006 761234
seed:0007 1184301
seed:0008 1091485
seed:0009 961333
```

時間延ばすとスコア伸びるので、しばしこの方向でできそうなことを掘ってみる。

TODO:順序関係の逆転を入れるべきかどうか（今のところは入ってる）


## 2022-09-18

> 順序関係の逆転を入れるべきかどうか（今のところは入ってる）

入れた方が1%くらい良い。ただしNが大きい場合は負けている。おそらく速度のせいなのでおいおい高速化できたら解消するでしょう

高いスコアが出ているケースの結果を見てみると、1列おきにまっすぐの四角で外側に伸ばすか、斜めの四角で外側に伸ばすかを交互に使うことで、
びっしり敷き詰めながら外向きに三角形の形で伸ばしていけていることがわかる。これをそこそこ安定して作れれば1位のスコアになりそう


外に近い方を先に埋めようとしてたけど、逆に中央に近い所を先に埋めた方が良かった

既存の点から探索を開始するのではなく、候補の四角を列挙しておいて新規の点が中央に近いやつから順に採用するようにしてみた
=> かなり悪い。そっか…。いったん諦め


時間伸ばして実行するだけでけっこう上がる。
といっても15sで平均104程度だからこれだけでは全然。


## 2022-09-23

いろいろ考えてみると、サイズ1な小さい四角だけで埋めると順序依存がなくて単に置けるところから置いていくだけで良くなる。

そうはいってもそんなきれいには埋まらないから、どれだけきれいに妥協できるかがポイントか。


ビジュアライザ作ろ

* 複数の解を順に表示できる
  * 一つの解の中でのアニメーションは公式ビジュアライザで見れば良いのでやらない
  * …と思ってたけどすぐに足せるので足した
* 四角の線の色を変えてどこが一つの四角なのかを視認できるようにする
  * 色をランダムに振ってみたけどそこまでわかりやすくはないな…
  * 各頂点からどっち向きに四角を出したかを頂点から短いひげを引いて表すようにしてみた
* 追加した頂点に、置いた順序を表示する

できた。やっぱりだいぶ公式よりステップ実行が軽くて良い。


## 2022-09-26

四角形全列挙して使う順番を状態として焼いてみる？
=> 別に良くはない。


## 2022-09-27

基本的には、線を引けるリソースは貴重なので使う四角は小さいほうが良い。

貪欲性が薄くて方針定めづらい

使いうる四角形の列挙をして順序を解決するような方向性はあるだろうか

「ここに点を置きたいから、そのためにはここに点がある必要があって…」と後退解析的にやるのはどうか


全然わからんので試しに愚直ビームサーチ書いてみるか
=> まあ動いたけど良くはない。端が同じ向きにそろってしまって外側に出て行ける形になってない。


# 2022-09-29

四角の向きを端で外側に出て行きやすいような形にそろえるような評価をしようとしてみるけどほとんど良くならない

高速化はすればするだけ良くなる。0.9秒で平均1162万、10秒で平均1363万

実装量そんなに多くないしC++にするか…？

